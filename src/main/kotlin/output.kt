import Clases.Block
import Clases.Edge
import Clases.EntityType
import FRA.Graph
import factorioBlueprint.Entity
import factorioBlueprint.Position
import java.awt.Color
import java.awt.Desktop
import java.io.File
import java.nio.file.Files
import java.nio.file.Path
import kotlin.math.roundToInt

fun header(size: Position): String {
    return "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n" +
            "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\n" +
            " \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n" +
            "<!-- Generated by sanders function\n" +
            " -->\n" +
            "<!-- Title: G Pages: 1 -->\n" +
            "<svg width=\"${size.x + 1}\" height=\"${size.y + 1}\" viewBox=\"-5 -5 ${size.x + 5} ${size.y + 5}\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n" +
            "<title>blueprinting image</title>\n" +
            "<rect width=\"${size.x + 10}\" height=\"${size.y + 10}\" x=\"-5\" y=\"-5\" fill=\"#8e8e8e\" />\n"

}

val listOfColors: List<Color> = listOf(
    Color.black,
    // Color.red,
    //Color.pink,
    Color(255, 125, 0),
    Color.yellow,
    // Color.green,
    Color.magenta,
    Color.orange,
    Color.cyan,
    Color.blue,
    Color.white,
    Color.black
)
var bagRandom: MutableList<Color> = listOfColors.toMutableList()

fun nextColor(): Color {
    if (bagRandom.isEmpty())
        bagRandom = listOfColors.toMutableList()
    val newC = bagRandom.random()
    bagRandom.remove(newC)
    return newC
}

fun svgFromPoints(size: Position, edgeList: ArrayList<Edge>, signalList: List<Entity>, graph: Graph<Block>) {
    val stringBuilder = StringBuilder()
    stringBuilder.append(header(size))

// schienen

    val dictionary: MutableMap<Int, Color> = mutableMapOf()

    edgeList.forEach { edge ->
        if (edge.collisionShape.size == 0) return@forEach
        val m = edge.collisionShape.joinToString { pos ->
            pos.x.roundToInt().toString() + "," + pos.y.roundToInt()
        }
        //color
        var color: Color = Color.BLACK
        //region random color
        if (CLIOptions[CLIFlags.EdgesGetRandomColor]!!) {
            if (edge.belongsToBlock != null) {
                if (dictionary.containsKey(edge.belongsToBlock!!.id)) {
                    color = dictionary[edge.belongsToBlock!!.id]!!
                } else {
                    color = nextColor()
                    dictionary[edge.belongsToBlock!!.id] = color
                }
            }
        }
        //endregion
        //add line for the edge
        stringBuilder.append("<path fill=\"none\" stroke=\"${color.toHex()}\" d=\"M$m\"/>\n")
        dbgPrintln {
            // add numbers to the blocks for debugging
            val b = edge.belongsToBlock
            if (b != null)
                stringBuilder.append("<text x=\"${b.pos().x}\" y=\"${b.pos().y}\"  font-size=\"5\" fill=\"green\">${b.id} </text>")
        }
    }
    signalList.forEach { sig ->
        if (sig.entityType == EntityType.Signal)
            stringBuilder.append("<circle r=\"0.5\" cx=\"${sig.position.x}\" cy=\"${sig.position.y}\" fill=\"${Color.green.toHex()}\" />\n")
        else
            stringBuilder.append("<circle r=\"0.5\" cx=\"${sig.position.x}\" cy=\"${sig.position.y}\" fill=\"${Color.pink.toHex()}\" />\n")
    }
    graph.dangerSigs.forEach {
        var pos = it.position
        stringBuilder.append("<circle r=\"2\" cx=\"${pos.x}\" cy=\"${pos.y}\"  fill=\"none\"  stroke=\"${Color.red.toHex()}\" stroke-width=\"0.3\" />\n")
    }
    stringBuilder.append("</svg>")
    if (!Files.exists(Path.of("GraphvizOutput"))) {
        Files.createDirectory(Path.of("GraphvizOutput"))
    }
    File("GraphvizOutput/BlueprintResult.svg").writeText(stringBuilder.toString())
    if (CLIOptions[CLIFlags.InstantShowOutput]!!) {
        val dt = Desktop.getDesktop()
        dt.open(File("GraphvizOutput/BlueprintResult.svg"))
    }
}